{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Blueprint \u00b6 Architectural frameworks and toolkits for bootstrapping modern Android codebases, written in Kotlin . Motivation \u00b6 These days whenever I kickoff a new Android project I always start by adding a bunch of infrastructure code (frameworks and toolkits) I developed over the years as they work really well in modern Android codebases which follow Clean Architecture and reactive paradigm , with strong emphasis on automated UI testing . These frameworks and toolkits have now become a library. Dependencies \u00b6 Blueprint offers multiple independent artifacts covering different use cases. But they are all \u201coptional\u201d which means you can choose to only use the ones that make sense for your codebase. Dependencies are hosted on Maven Central . Latest stable version: def blueprint_version = \"1.15.0\" If you use Kotlin Coroutines and Flow : // Building Interactors based on Kotlin Coroutines and Flow implementation \"io.github.reactivecircus.blueprint:blueprint-interactor-coroutines:${blueprint_version}\" // Wrapper API for doing async work with Kotlin CoroutineDispatcher implementation \"io.github.reactivecircus.blueprint:blueprint-async-coroutines:${blueprint_version}\" // Android UI extensions, utilities and widgets implementation \"io.github.reactivecircus.blueprint:blueprint-ui:${blueprint_version}\" // Android UI testing framework with Testing Robot DSL implementation \"io.github.reactivecircus.blueprint:blueprint-testing-robot:${blueprint_version}\" If you use RxJava 2 : // Building Interactors based on RxJava 2 implementation \"io.github.reactivecircus.blueprint:blueprint-interactor-rx2:${blueprint_version}\" // Wrapper API for doing async work with RxJava 2 Schedulers implementation \"io.github.reactivecircus.blueprint:blueprint-async-rx2:${blueprint_version}\" // Android UI extensions, utilities and widgets implementation \"io.github.reactivecircus.blueprint:blueprint-ui:${blueprint_version}\" // Android UI testing framework with Testing Robot DSL implementation \"io.github.reactivecircus.blueprint:blueprint-testing-robot:${blueprint_version}\" If you use RxJava 3 : // Building Interactors based on RxJava 3 implementation \"io.github.reactivecircus.blueprint:blueprint-interactor-rx3:${blueprint_version}\" // Wrapper API for doing async work with RxJava 3 Schedulers implementation \"io.github.reactivecircus.blueprint:blueprint-async-rx3:${blueprint_version}\" // Android UI extensions, utilities and widgets implementation \"io.github.reactivecircus.blueprint:blueprint-ui:${blueprint_version}\" // Android UI testing framework with Testing Robot DSL implementation \"io.github.reactivecircus.blueprint:blueprint-testing-robot:${blueprint_version}\" Snapshots of the development version are available in Sonatype\u2019s snapshots repository . Samples \u00b6 There are a couple of sample apps demonstrating how you may use Blueprint , one based on Kotlin Coroutines and the other one based on RxJava 2 . Overview \u00b6 The following is a high-level overview of what each Blueprint artifact does. For details and sample usage please check the samples and the documentation ( README.md ) in each of the sub-projects. Blueprint Interactor Coroutines \u00b6 This artifact provides 2 base classes for building Interactors (use case in Clean Architecture): SuspendingInteractor for single-shot tasks FlowInteractor for cold streams Please check blueprint-interactor-coroutines for details. Blueprint Async Coroutines \u00b6 This artifact provides a CoroutineDispatcherProvider API for encapsulating the threading behavior with Kotlin CoroutineDispatcher. Please check blueprint-async-coroutines for details. Blueprint Interactor RxJava 2 \u00b6 This artifact provides 3 base classes for building Interactors (use case in Clean Architecture): SingleInteractor for single-shot (with result) tasks CompletableInteractor for single-shot (no result) tasks ObservableInteractor for cold streams Please check blueprint-interactor-rx2 for details. Blueprint Async RxJava 2 \u00b6 This artifact provides a SchedulerProvider API for encapsulating the threading behavior with RxJava 2 Schedulers. Please check blueprint-async-rx2 for details. Blueprint Interactor RxJava 3 \u00b6 This artifact provides 3 base classes for building Interactors (use case in Clean Architecture): SingleInteractor for single-shot (with result) tasks CompletableInteractor for single-shot (no result) tasks ObservableInteractor for cold streams Please check blueprint-interactor-rx3 for details. Blueprint Async RxJava 3 \u00b6 This artifact provides a SchedulerProvider API for encapsulating the threading behavior with RxJava 3 Schedulers. Please check blueprint-async-rx3 for details. Blueprint UI \u00b6 This artifact provides convenient Kotlin extensions and widgets for working with the Android UI toolkit. Please check blueprint-ui for details. Blueprint Testing Robot \u00b6 This artifact provides a UI testing framework and Testing Robot DSL for authoring structured, readable, and framework-agnostic UI tests. Please check blueprint-testing-robot for details. License \u00b6 Copyright 2019 Yang Chen Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#blueprint","text":"Architectural frameworks and toolkits for bootstrapping modern Android codebases, written in Kotlin .","title":"Blueprint"},{"location":"#motivation","text":"These days whenever I kickoff a new Android project I always start by adding a bunch of infrastructure code (frameworks and toolkits) I developed over the years as they work really well in modern Android codebases which follow Clean Architecture and reactive paradigm , with strong emphasis on automated UI testing . These frameworks and toolkits have now become a library.","title":"Motivation"},{"location":"#dependencies","text":"Blueprint offers multiple independent artifacts covering different use cases. But they are all \u201coptional\u201d which means you can choose to only use the ones that make sense for your codebase. Dependencies are hosted on Maven Central . Latest stable version: def blueprint_version = \"1.15.0\" If you use Kotlin Coroutines and Flow : // Building Interactors based on Kotlin Coroutines and Flow implementation \"io.github.reactivecircus.blueprint:blueprint-interactor-coroutines:${blueprint_version}\" // Wrapper API for doing async work with Kotlin CoroutineDispatcher implementation \"io.github.reactivecircus.blueprint:blueprint-async-coroutines:${blueprint_version}\" // Android UI extensions, utilities and widgets implementation \"io.github.reactivecircus.blueprint:blueprint-ui:${blueprint_version}\" // Android UI testing framework with Testing Robot DSL implementation \"io.github.reactivecircus.blueprint:blueprint-testing-robot:${blueprint_version}\" If you use RxJava 2 : // Building Interactors based on RxJava 2 implementation \"io.github.reactivecircus.blueprint:blueprint-interactor-rx2:${blueprint_version}\" // Wrapper API for doing async work with RxJava 2 Schedulers implementation \"io.github.reactivecircus.blueprint:blueprint-async-rx2:${blueprint_version}\" // Android UI extensions, utilities and widgets implementation \"io.github.reactivecircus.blueprint:blueprint-ui:${blueprint_version}\" // Android UI testing framework with Testing Robot DSL implementation \"io.github.reactivecircus.blueprint:blueprint-testing-robot:${blueprint_version}\" If you use RxJava 3 : // Building Interactors based on RxJava 3 implementation \"io.github.reactivecircus.blueprint:blueprint-interactor-rx3:${blueprint_version}\" // Wrapper API for doing async work with RxJava 3 Schedulers implementation \"io.github.reactivecircus.blueprint:blueprint-async-rx3:${blueprint_version}\" // Android UI extensions, utilities and widgets implementation \"io.github.reactivecircus.blueprint:blueprint-ui:${blueprint_version}\" // Android UI testing framework with Testing Robot DSL implementation \"io.github.reactivecircus.blueprint:blueprint-testing-robot:${blueprint_version}\" Snapshots of the development version are available in Sonatype\u2019s snapshots repository .","title":"Dependencies"},{"location":"#samples","text":"There are a couple of sample apps demonstrating how you may use Blueprint , one based on Kotlin Coroutines and the other one based on RxJava 2 .","title":"Samples"},{"location":"#overview","text":"The following is a high-level overview of what each Blueprint artifact does. For details and sample usage please check the samples and the documentation ( README.md ) in each of the sub-projects.","title":"Overview"},{"location":"#blueprint-interactor-coroutines","text":"This artifact provides 2 base classes for building Interactors (use case in Clean Architecture): SuspendingInteractor for single-shot tasks FlowInteractor for cold streams Please check blueprint-interactor-coroutines for details.","title":"Blueprint Interactor Coroutines"},{"location":"#blueprint-async-coroutines","text":"This artifact provides a CoroutineDispatcherProvider API for encapsulating the threading behavior with Kotlin CoroutineDispatcher. Please check blueprint-async-coroutines for details.","title":"Blueprint Async Coroutines"},{"location":"#blueprint-interactor-rxjava-2","text":"This artifact provides 3 base classes for building Interactors (use case in Clean Architecture): SingleInteractor for single-shot (with result) tasks CompletableInteractor for single-shot (no result) tasks ObservableInteractor for cold streams Please check blueprint-interactor-rx2 for details.","title":"Blueprint Interactor RxJava 2"},{"location":"#blueprint-async-rxjava-2","text":"This artifact provides a SchedulerProvider API for encapsulating the threading behavior with RxJava 2 Schedulers. Please check blueprint-async-rx2 for details.","title":"Blueprint Async RxJava 2"},{"location":"#blueprint-interactor-rxjava-3","text":"This artifact provides 3 base classes for building Interactors (use case in Clean Architecture): SingleInteractor for single-shot (with result) tasks CompletableInteractor for single-shot (no result) tasks ObservableInteractor for cold streams Please check blueprint-interactor-rx3 for details.","title":"Blueprint Interactor RxJava 3"},{"location":"#blueprint-async-rxjava-3","text":"This artifact provides a SchedulerProvider API for encapsulating the threading behavior with RxJava 3 Schedulers. Please check blueprint-async-rx3 for details.","title":"Blueprint Async RxJava 3"},{"location":"#blueprint-ui","text":"This artifact provides convenient Kotlin extensions and widgets for working with the Android UI toolkit. Please check blueprint-ui for details.","title":"Blueprint UI"},{"location":"#blueprint-testing-robot","text":"This artifact provides a UI testing framework and Testing Robot DSL for authoring structured, readable, and framework-agnostic UI tests. Please check blueprint-testing-robot for details.","title":"Blueprint Testing Robot"},{"location":"#license","text":"Copyright 2019 Yang Chen Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Change Log \u00b6 Version 1.16.0 \u00b6 2021-05-30 Fix clickTextInputLayoutErrorIcon(viewId) and longClickTextInputLayoutErrorIcon(viewId) . Kotlin 1.5.10. Coroutines 1.5.0. Update AndroidX. Version 1.15.0 \u00b6 2021-02-26 Breaking change: activity.showKeyboard() and Activity.hideKeyboard(focusedView: View) have been replaced with Window.showSoftKeyboard() and Window.hideSoftKeyboard() using the WindowInsetsControllerCompat APIs. Replace deprecated systemUiVisibility with WindowInsetsControllerCompat . Enable IR compiler. Kotlin 1.4.31. Coroutines 1.4.2. Update AndroidX and MDC. Version 1.14.1 \u00b6 2020-09-14 Disable IR compiler. Version 1.14.0 \u00b6 2020-09-14 Breaking change: fun Context.resolveColorAttr(@AttrRes colorAttr: Int): Int has been removed. Use MaterialColors from MDC instead. Update AppCompatTextView.setPrecomputedTextFuture(charSequence: charSequence, executor: Executor? = null) to allow passing in null as charSequence . Update MDC and Kotlin. Enable IR compiler. Generate API docs with Dokka 1.4. Version 1.13.0 \u00b6 2020-08-29 New RobotAssertions.viewNotExists(@IdRes vararg viewIds: Int) for asserting that views are not present in the view hierarchy. New withItemViewType(@IdRes recyclerViewId: Int, itemViewType: Int): Matcher<View> for matching RecyclerView item by itemViewType . Version 1.12.0 \u00b6 2020-08-16 Update to Kotlin 1.4.0 and Coroutines 1.3.9. Enable explicit API mode. Update AndroidX and MDC. Version 1.11.0 \u00b6 2020-07-23 Move all AndroidX dependencies to the latest stable version. Version 1.10.0 \u00b6 2020-07-17 New RobotAssertions.viewEndsWithText(@IdRes viewId: Int, expected: String) for asserting that a view has text that ends with the expected string. Fix RobotAssertions.viewStartsWithText(@IdRes viewId: Int, expected: String) . Depend on kotlin-sdtlib instead of kotlin-stdlib-jdk8 Update Coroutines, AndroidX and MDC. Version 1.9.0 \u00b6 2020-05-30 Breaking change: clickTextInputLayoutIcon(@IdRes viewId: Int, endIcon: Boolean) has been refactored into clickTextInputLayoutStartIcon(@IdRes viewId: Int) and clickTextInputLayoutEndIcon(@IdRes viewId: Int) . Breaking change: longClickTextInputLayoutIcon(@IdRes viewId: Int, endIcon: Boolean) has been refactored into longClickTextInputLayoutStartIcon(@IdRes viewId: Int) and longClickTextInputLayoutEndIcon(@IdRes viewId: Int) . New clickTextInputLayoutErrorIcon(@IdRes viewId: Int) and longClickTextInputLayoutErrorIcon(@IdRes viewId: Int) extensions on the TextInputLayout . Update AGP, Gradle, Coroutines, RxJava 3, AndroidX, MDC, detekt. Version 1.8.1 \u00b6 2020-05-10 Fix a publishing issue. Version 1.8.0 \u00b6 2020-05-09 Breaking change: Context.isAnimationOn is now a property extension. Update Kotlin, AGP, Coroutines, RxJava 3, AndroidX, detekt, LeakCanary. Coroutines sample has been updated to replace LiveData with the new StateFlow introduced in Coroutines 1.3.6. Version 1.7.1 \u00b6 2020-04-11 Update Kotlin, AGP, RxJava 2, RxJava 3, RxKotlin 3, AndroidX, detekt. Version 1.6.0 \u00b6 2020-03-09 New clearToolbarScrollFlags(@IdRes toolbarId: Int) for clearing any scrolling behavior on the toolbar . Internal improvements on blueprint-testing-robot . Version 1.5.0 \u00b6 2020-03-08 New onRecyclerViewIdle(@IdRes recyclerViewId: Int) for waiting until RecyclerView has no more pending updates. Fix RecyclerViewItemCountAssertion \u2018s param type nullability. Update Kotlin, AGP, Gradle, RxJava 2, RxJava 3, RxKotlin 3, RxAndroid 3, LeakCanary, AndroidX, MDC, detekt. Version 1.4.0 \u00b6 2020-01-19 Breaking change: blueprint-threading-coroutines has been renamed to blueprint-async-coroutines . Breaking change: blueprint-threading-rx2 has been renamed to blueprint-async-rx2 . Breaking change: blueprint-threading-rx3 has been renamed to blueprint-async-rx3 . Update Kotlin, AGP, Gradle, RxJava 2, RxJava 3, LeakCanary, AndroidX, MDC, JUnit, detekt. Version 1.3.1 \u00b6 2019-12-03 Fix RobotAssertions.textInputLayoutHasNoError which wasn\u2019t properly checking whether error message is empty. Update Kotlin, AGP, Gradle, RxJava 2, LeakCanary, AndroidX, MDC, kluent, detekt. Version 1.3.0 \u00b6 2019-10-17 New RobotAction for selecting a navigation item from the drawer. New RobotAction for clicking TextInputLayout \u2018s start / end icon. New RobotAction for long clicking TextInputLayout \u2018s start / end icon. Migrate to custom Gradle plugin for managing build configs. Update AGP, Gradle, RxJava 2, Coroutines, AndroidX, MDC, kluent, detekt. Improve samples. Version 1.2.0 \u00b6 2019-08-28 blueprint-ui - Added new extension for setting precomputed text on AppCompatTextView . Refactor blueprint-ui internals. Disable BuildConfig generation for Android library modules. Stop exposing resources from transitive dependencies for Android library modules. Update AGP, Gradle, RxJava 2, Coroutines, detekt, LeakCanary. Improve documentation. Version 1.1.0 \u00b6 2019-08-20 New RobotAction for clicking on the action button on the currently displayed snackbar. Refactor / simplify blueprint-testing-robot internals. Update RxJava 3 to RC2 - this is a breaking change as RxJava 3 base package now has rxjava3 . Update AGP, AndroidX, Coroutines, detekt. Improve documentation. Version 1.0.1 \u00b6 2019-08-02 Fix a publishing issue. All artifacts should now be available on Maven Central. Version 1.0.0 \u00b6 2019-08-02 This is the initial release of Blueprint - a collection of Architectural frameworks and toolkits for bootstrapping modern Android codebases. New: blueprint-interactor-coroutines artifact - supports building Interactors based on Kotlin Coroutines and Flow. New: blueprint-interactor-rx2 artifact - supports building Interactors based on RxJava 2. New: blueprint-interactor-rx3 artifact - supports building Interactors based on RxJava 3. Note that it currently uses RxJava 3.0.0-RC1, and RxAndroid has not yet been updated to target RxJava 3.x yet. New: blueprint-threading-coroutines artifact - provides encapsulation of threading behavior with Kotlin CoroutineDispatcher . New: blueprint-threading-rx2 artifact - provides encapsulation of threading behavior with RxJava 2 Scheduler . New: blueprint-threading-rx3 artifact - provides encapsulation of threading behavior with RxJava 3 Scheduler . Note that it currently uses RxJava 3.0.0-RC1, and RxAndroid has not yet been updated to target RxJava 3.x yet. New: blueprint-ui artifact - Kotlin extensions and widgets for working with the Android UI toolkit. New: blueprint-testing-robot artifact - UI testing framework and DSL for authoring structured, readable, and framework-agnostic UI tests.","title":"Change Log"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#version-1160","text":"2021-05-30 Fix clickTextInputLayoutErrorIcon(viewId) and longClickTextInputLayoutErrorIcon(viewId) . Kotlin 1.5.10. Coroutines 1.5.0. Update AndroidX.","title":"Version 1.16.0"},{"location":"changelog/#version-1150","text":"2021-02-26 Breaking change: activity.showKeyboard() and Activity.hideKeyboard(focusedView: View) have been replaced with Window.showSoftKeyboard() and Window.hideSoftKeyboard() using the WindowInsetsControllerCompat APIs. Replace deprecated systemUiVisibility with WindowInsetsControllerCompat . Enable IR compiler. Kotlin 1.4.31. Coroutines 1.4.2. Update AndroidX and MDC.","title":"Version 1.15.0"},{"location":"changelog/#version-1141","text":"2020-09-14 Disable IR compiler.","title":"Version 1.14.1"},{"location":"changelog/#version-1140","text":"2020-09-14 Breaking change: fun Context.resolveColorAttr(@AttrRes colorAttr: Int): Int has been removed. Use MaterialColors from MDC instead. Update AppCompatTextView.setPrecomputedTextFuture(charSequence: charSequence, executor: Executor? = null) to allow passing in null as charSequence . Update MDC and Kotlin. Enable IR compiler. Generate API docs with Dokka 1.4.","title":"Version 1.14.0"},{"location":"changelog/#version-1130","text":"2020-08-29 New RobotAssertions.viewNotExists(@IdRes vararg viewIds: Int) for asserting that views are not present in the view hierarchy. New withItemViewType(@IdRes recyclerViewId: Int, itemViewType: Int): Matcher<View> for matching RecyclerView item by itemViewType .","title":"Version 1.13.0"},{"location":"changelog/#version-1120","text":"2020-08-16 Update to Kotlin 1.4.0 and Coroutines 1.3.9. Enable explicit API mode. Update AndroidX and MDC.","title":"Version 1.12.0"},{"location":"changelog/#version-1110","text":"2020-07-23 Move all AndroidX dependencies to the latest stable version.","title":"Version 1.11.0"},{"location":"changelog/#version-1100","text":"2020-07-17 New RobotAssertions.viewEndsWithText(@IdRes viewId: Int, expected: String) for asserting that a view has text that ends with the expected string. Fix RobotAssertions.viewStartsWithText(@IdRes viewId: Int, expected: String) . Depend on kotlin-sdtlib instead of kotlin-stdlib-jdk8 Update Coroutines, AndroidX and MDC.","title":"Version 1.10.0"},{"location":"changelog/#version-190","text":"2020-05-30 Breaking change: clickTextInputLayoutIcon(@IdRes viewId: Int, endIcon: Boolean) has been refactored into clickTextInputLayoutStartIcon(@IdRes viewId: Int) and clickTextInputLayoutEndIcon(@IdRes viewId: Int) . Breaking change: longClickTextInputLayoutIcon(@IdRes viewId: Int, endIcon: Boolean) has been refactored into longClickTextInputLayoutStartIcon(@IdRes viewId: Int) and longClickTextInputLayoutEndIcon(@IdRes viewId: Int) . New clickTextInputLayoutErrorIcon(@IdRes viewId: Int) and longClickTextInputLayoutErrorIcon(@IdRes viewId: Int) extensions on the TextInputLayout . Update AGP, Gradle, Coroutines, RxJava 3, AndroidX, MDC, detekt.","title":"Version 1.9.0"},{"location":"changelog/#version-181","text":"2020-05-10 Fix a publishing issue.","title":"Version 1.8.1"},{"location":"changelog/#version-180","text":"2020-05-09 Breaking change: Context.isAnimationOn is now a property extension. Update Kotlin, AGP, Coroutines, RxJava 3, AndroidX, detekt, LeakCanary. Coroutines sample has been updated to replace LiveData with the new StateFlow introduced in Coroutines 1.3.6.","title":"Version 1.8.0"},{"location":"changelog/#version-171","text":"2020-04-11 Update Kotlin, AGP, RxJava 2, RxJava 3, RxKotlin 3, AndroidX, detekt.","title":"Version 1.7.1"},{"location":"changelog/#version-160","text":"2020-03-09 New clearToolbarScrollFlags(@IdRes toolbarId: Int) for clearing any scrolling behavior on the toolbar . Internal improvements on blueprint-testing-robot .","title":"Version 1.6.0"},{"location":"changelog/#version-150","text":"2020-03-08 New onRecyclerViewIdle(@IdRes recyclerViewId: Int) for waiting until RecyclerView has no more pending updates. Fix RecyclerViewItemCountAssertion \u2018s param type nullability. Update Kotlin, AGP, Gradle, RxJava 2, RxJava 3, RxKotlin 3, RxAndroid 3, LeakCanary, AndroidX, MDC, detekt.","title":"Version 1.5.0"},{"location":"changelog/#version-140","text":"2020-01-19 Breaking change: blueprint-threading-coroutines has been renamed to blueprint-async-coroutines . Breaking change: blueprint-threading-rx2 has been renamed to blueprint-async-rx2 . Breaking change: blueprint-threading-rx3 has been renamed to blueprint-async-rx3 . Update Kotlin, AGP, Gradle, RxJava 2, RxJava 3, LeakCanary, AndroidX, MDC, JUnit, detekt.","title":"Version 1.4.0"},{"location":"changelog/#version-131","text":"2019-12-03 Fix RobotAssertions.textInputLayoutHasNoError which wasn\u2019t properly checking whether error message is empty. Update Kotlin, AGP, Gradle, RxJava 2, LeakCanary, AndroidX, MDC, kluent, detekt.","title":"Version 1.3.1"},{"location":"changelog/#version-130","text":"2019-10-17 New RobotAction for selecting a navigation item from the drawer. New RobotAction for clicking TextInputLayout \u2018s start / end icon. New RobotAction for long clicking TextInputLayout \u2018s start / end icon. Migrate to custom Gradle plugin for managing build configs. Update AGP, Gradle, RxJava 2, Coroutines, AndroidX, MDC, kluent, detekt. Improve samples.","title":"Version 1.3.0"},{"location":"changelog/#version-120","text":"2019-08-28 blueprint-ui - Added new extension for setting precomputed text on AppCompatTextView . Refactor blueprint-ui internals. Disable BuildConfig generation for Android library modules. Stop exposing resources from transitive dependencies for Android library modules. Update AGP, Gradle, RxJava 2, Coroutines, detekt, LeakCanary. Improve documentation.","title":"Version 1.2.0"},{"location":"changelog/#version-110","text":"2019-08-20 New RobotAction for clicking on the action button on the currently displayed snackbar. Refactor / simplify blueprint-testing-robot internals. Update RxJava 3 to RC2 - this is a breaking change as RxJava 3 base package now has rxjava3 . Update AGP, AndroidX, Coroutines, detekt. Improve documentation.","title":"Version 1.1.0"},{"location":"changelog/#version-101","text":"2019-08-02 Fix a publishing issue. All artifacts should now be available on Maven Central.","title":"Version 1.0.1"},{"location":"changelog/#version-100","text":"2019-08-02 This is the initial release of Blueprint - a collection of Architectural frameworks and toolkits for bootstrapping modern Android codebases. New: blueprint-interactor-coroutines artifact - supports building Interactors based on Kotlin Coroutines and Flow. New: blueprint-interactor-rx2 artifact - supports building Interactors based on RxJava 2. New: blueprint-interactor-rx3 artifact - supports building Interactors based on RxJava 3. Note that it currently uses RxJava 3.0.0-RC1, and RxAndroid has not yet been updated to target RxJava 3.x yet. New: blueprint-threading-coroutines artifact - provides encapsulation of threading behavior with Kotlin CoroutineDispatcher . New: blueprint-threading-rx2 artifact - provides encapsulation of threading behavior with RxJava 2 Scheduler . New: blueprint-threading-rx3 artifact - provides encapsulation of threading behavior with RxJava 3 Scheduler . Note that it currently uses RxJava 3.0.0-RC1, and RxAndroid has not yet been updated to target RxJava 3.x yet. New: blueprint-ui artifact - Kotlin extensions and widgets for working with the Android UI toolkit. New: blueprint-testing-robot artifact - UI testing framework and DSL for authoring structured, readable, and framework-agnostic UI tests.","title":"Version 1.0.0"},{"location":"blueprint-async-coroutines/","text":"Blueprint Async Coroutines \u00b6 This library provides a CoroutineDispatcherProvider class to encapsulate the threading behavior with a wrapper API. Dependency \u00b6 implementation \"io.github.reactivecircus.blueprint:blueprint-async-coroutines:${blueprint_version}\" Usage \u00b6 CoroutineDispatcherProvider has 3 properties, representing the common groups of threading use cases in an app: io: CoroutineDispatcher - Dispatcher for IO-bound work computation: CoroutineDispatcher - Dispatcher for computational work ui: CoroutineDispatcher - Dispatcher for UI work An instance of this can be injected to classes which are concerned about executing code on different threads, but they don\u2019t and shouldn\u2019t need to know about the underlying implementation. A single-threaded version for example can be injected for testing. Practically you\u2019ll likely only have 1 instance of CoroutineDispatcherProvider in the production environment and use DI to inject it into anywhere in the codebase where certain threading behavior is required: CoroutineDispatcherProvider ( io = Dispatchers . IO , computation = Dispatchers . Default , ui = Dispatchers . Main . immediate ) In unit tests you can easily swap out the implementation to make sure code is executed in a single thread: CoroutineDispatcherProvider ( io = testCoroutineDispatcher , computation = testCoroutineDispatcher , ui = testCoroutineDispatcher ) where testCoroutineDispatcher is an instance of TestCoroutineDispatcher from the org.jetbrains.kotlinx:kotlinx-coroutines-test library.","title":"Async Coroutines"},{"location":"blueprint-async-coroutines/#blueprint-async-coroutines","text":"This library provides a CoroutineDispatcherProvider class to encapsulate the threading behavior with a wrapper API.","title":"Blueprint Async Coroutines"},{"location":"blueprint-async-coroutines/#dependency","text":"implementation \"io.github.reactivecircus.blueprint:blueprint-async-coroutines:${blueprint_version}\"","title":"Dependency"},{"location":"blueprint-async-coroutines/#usage","text":"CoroutineDispatcherProvider has 3 properties, representing the common groups of threading use cases in an app: io: CoroutineDispatcher - Dispatcher for IO-bound work computation: CoroutineDispatcher - Dispatcher for computational work ui: CoroutineDispatcher - Dispatcher for UI work An instance of this can be injected to classes which are concerned about executing code on different threads, but they don\u2019t and shouldn\u2019t need to know about the underlying implementation. A single-threaded version for example can be injected for testing. Practically you\u2019ll likely only have 1 instance of CoroutineDispatcherProvider in the production environment and use DI to inject it into anywhere in the codebase where certain threading behavior is required: CoroutineDispatcherProvider ( io = Dispatchers . IO , computation = Dispatchers . Default , ui = Dispatchers . Main . immediate ) In unit tests you can easily swap out the implementation to make sure code is executed in a single thread: CoroutineDispatcherProvider ( io = testCoroutineDispatcher , computation = testCoroutineDispatcher , ui = testCoroutineDispatcher ) where testCoroutineDispatcher is an instance of TestCoroutineDispatcher from the org.jetbrains.kotlinx:kotlinx-coroutines-test library.","title":"Usage"},{"location":"blueprint-async-rx2/","text":"Blueprint Async RxJava 2 \u00b6 This library provides a SchedulerProvider class to encapsulate the threading behavior with a wrapper API. Dependency \u00b6 implementation \"io.github.reactivecircus.blueprint:blueprint-async-rx2:${blueprint_version}\" Usage \u00b6 SchedulerProvider has 3 properties, representing the common groups of threading use cases in an app: io: Scheduler - Scheduler for IO-bound work computation: Scheduler - Scheduler for computational work ui: Scheduler - Scheduler for UI work An instance of this can be injected to classes which are concerned about executing code on different threads, but they don\u2019t and shouldn\u2019t need to know about the underlying implementation. A single-threaded version for example can be injected for testing. Practically you\u2019ll likely only have 1 instance of SchedulerProvider in the production environment and use DI to inject it into anywhere in the codebase where certain threading behavior is required: SchedulerProvider ( io = Schedulers . io (), computation = Schedulers . computation (), ui = AndroidSchedulers . mainThread () ) In unit tests you can easily swap out the implementation to make sure code is executed in a single thread: SchedulerProvider ( io = Schedulers . trampoline (), computation = Schedulers . trampoline (), ui = Schedulers . trampoline () )","title":"Async RxJava 2"},{"location":"blueprint-async-rx2/#blueprint-async-rxjava-2","text":"This library provides a SchedulerProvider class to encapsulate the threading behavior with a wrapper API.","title":"Blueprint Async RxJava 2"},{"location":"blueprint-async-rx2/#dependency","text":"implementation \"io.github.reactivecircus.blueprint:blueprint-async-rx2:${blueprint_version}\"","title":"Dependency"},{"location":"blueprint-async-rx2/#usage","text":"SchedulerProvider has 3 properties, representing the common groups of threading use cases in an app: io: Scheduler - Scheduler for IO-bound work computation: Scheduler - Scheduler for computational work ui: Scheduler - Scheduler for UI work An instance of this can be injected to classes which are concerned about executing code on different threads, but they don\u2019t and shouldn\u2019t need to know about the underlying implementation. A single-threaded version for example can be injected for testing. Practically you\u2019ll likely only have 1 instance of SchedulerProvider in the production environment and use DI to inject it into anywhere in the codebase where certain threading behavior is required: SchedulerProvider ( io = Schedulers . io (), computation = Schedulers . computation (), ui = AndroidSchedulers . mainThread () ) In unit tests you can easily swap out the implementation to make sure code is executed in a single thread: SchedulerProvider ( io = Schedulers . trampoline (), computation = Schedulers . trampoline (), ui = Schedulers . trampoline () )","title":"Usage"},{"location":"blueprint-async-rx3/","text":"Blueprint Async RxJava 3 \u00b6 This library provides a SchedulerProvider class to encapsulate the threading behavior with a wrapper API. Dependency \u00b6 implementation \"io.github.reactivecircus.blueprint:blueprint-async-rx3:${blueprint_version}\" Usage \u00b6 SchedulerProvider has 3 properties, representing the common groups of threading use cases in an app: io: Scheduler - Scheduler for IO-bound work computation: Scheduler - Scheduler for computational work ui: Scheduler - Scheduler for UI work An instance of this can be injected to classes which are concerned about executing code on different threads, but they don\u2019t and shouldn\u2019t need to know about the underlying implementation. A single-threaded version for example can be injected for testing. Practically you\u2019ll likely only have 1 instance of SchedulerProvider in the production environment and use DI to inject it into anywhere in the codebase where certain threading behavior is required: SchedulerProvider ( io = Schedulers . io (), computation = Schedulers . computation (), ui = AndroidSchedulers . mainThread () ) In unit tests you can easily swap out the implementation to make sure code is executed in a single thread: SchedulerProvider ( io = Schedulers . trampoline (), computation = Schedulers . trampoline (), ui = Schedulers . trampoline () )","title":"Async RxJava 3"},{"location":"blueprint-async-rx3/#blueprint-async-rxjava-3","text":"This library provides a SchedulerProvider class to encapsulate the threading behavior with a wrapper API.","title":"Blueprint Async RxJava 3"},{"location":"blueprint-async-rx3/#dependency","text":"implementation \"io.github.reactivecircus.blueprint:blueprint-async-rx3:${blueprint_version}\"","title":"Dependency"},{"location":"blueprint-async-rx3/#usage","text":"SchedulerProvider has 3 properties, representing the common groups of threading use cases in an app: io: Scheduler - Scheduler for IO-bound work computation: Scheduler - Scheduler for computational work ui: Scheduler - Scheduler for UI work An instance of this can be injected to classes which are concerned about executing code on different threads, but they don\u2019t and shouldn\u2019t need to know about the underlying implementation. A single-threaded version for example can be injected for testing. Practically you\u2019ll likely only have 1 instance of SchedulerProvider in the production environment and use DI to inject it into anywhere in the codebase where certain threading behavior is required: SchedulerProvider ( io = Schedulers . io (), computation = Schedulers . computation (), ui = AndroidSchedulers . mainThread () ) In unit tests you can easily swap out the implementation to make sure code is executed in a single thread: SchedulerProvider ( io = Schedulers . trampoline (), computation = Schedulers . trampoline (), ui = Schedulers . trampoline () )","title":"Usage"},{"location":"blueprint-interactor-coroutines/","text":"Blueprint Interactor Coroutines \u00b6 This library provides building blocks for writing Interactors (use cases as defined in Clean Architecture ) based on Kotlin Coroutines and Flow . Dependency \u00b6 implementation \"io.github.reactivecircus.blueprint:blueprint-interactor-coroutines:${blueprint_version}\" Usage \u00b6 To implement an Interactor we would extend from one of the 2 classes provided: SuspendingInteractor for single-shot tasks FlowInteractor for cold streams Let\u2019s say we need an Interactor for fetching a list of users from API. Since there can only be 1 response (or error), our Interactor should extend from SuspendingInteractor : class FetchUsers ( private val userService : UserService , coroutineDispatcherProvider : CoroutineDispatcherProvider ) : SuspendingInteractor < EmptyParams , List < User >> () { override val dispatcher : CoroutineDispatcher = coroutineDispatcherProvider . io override suspend fun doWork ( params : EmptyParams ): List < User > { userService . fetchUsers () } } To execute this Interactor, call the execute(...) suspend function from a CoroutineScope : viewModelScope . launch { // EmptyParams is a special [InteractorParams] which you can use when the Interactor has no params. val users : List < User > = fetchUsers . execute ( EmptyParams ) } Note that the CoroutineDispatcherProvider in the constructor of the Interactor comes from the blueprint-async-coroutines artifact, which encapsulates the threading behavior with a wrapper API. Now let\u2019s implement another Interactor for updating a user profile. This interactor expects no result and we just need to know the whether it has been completed successfully. So our Interactor should again extend from SuspendingInteractor : class UpdateUserProfile ( private val userService : UserService , coroutineDispatcherProvider : CoroutineDispatcherProvider ) : SuspendingInteractor < UpdateUserProfile . Params , Unit > () { override val dispatcher : CoroutineDispatcher = coroutineDispatcherProvider . io override suspend fun doWork ( params : Params ) { userService . updateUserProfile ( params . userProfile ) } class Params ( internal val userProfile : UserProfile ) : InteractorParams } To execute this Interactor, call the execute(...) suspend function from a CoroutineScope : viewModelScope . launch { // this returns a Unit updateUserProfile . execute ( UpdateUserProfile . Params ( userProfile )) } In a reactive architecture we might want to stream any changes to the users persisted in the database to automatically re-render the UI whenever the user list has changed. In this case it makes sense to extend from the FlowInteractor : class StreamUsers ( private val userRepository : UserRepository , coroutineDispatcherProvider : CoroutineDispatcherProvider ) : FlowInteractor < EmptyParams , List < User >> () { override val dispatcher : CoroutineDispatcher = coroutineDispatcherProvider . io override fun createFlow ( params : Params ): Flow < List < User >> { return userRepository . streamUsers () // this returns a Coroutines Flow . map { users -> users . sortedBy { it . lastName } } } } On the call-side: streamUsers . buildFlow ( EmptyParams ) . onEach { users -> // propagate value of each Flow emission to LiveData<List<User>> usersLiveData . value = users } . catch { Timber . e ( it ) } // launch the collection of the Flow in the [viewModelScope] from \"androidx.lifecycle:lifecycle-viewmodel-ktx\" . launchIn ( viewModelScope ) Please check the Blueprint Coroutines Demo app for more examples of writing and testing Interactors.","title":"Interactor Coroutines"},{"location":"blueprint-interactor-coroutines/#blueprint-interactor-coroutines","text":"This library provides building blocks for writing Interactors (use cases as defined in Clean Architecture ) based on Kotlin Coroutines and Flow .","title":"Blueprint Interactor Coroutines"},{"location":"blueprint-interactor-coroutines/#dependency","text":"implementation \"io.github.reactivecircus.blueprint:blueprint-interactor-coroutines:${blueprint_version}\"","title":"Dependency"},{"location":"blueprint-interactor-coroutines/#usage","text":"To implement an Interactor we would extend from one of the 2 classes provided: SuspendingInteractor for single-shot tasks FlowInteractor for cold streams Let\u2019s say we need an Interactor for fetching a list of users from API. Since there can only be 1 response (or error), our Interactor should extend from SuspendingInteractor : class FetchUsers ( private val userService : UserService , coroutineDispatcherProvider : CoroutineDispatcherProvider ) : SuspendingInteractor < EmptyParams , List < User >> () { override val dispatcher : CoroutineDispatcher = coroutineDispatcherProvider . io override suspend fun doWork ( params : EmptyParams ): List < User > { userService . fetchUsers () } } To execute this Interactor, call the execute(...) suspend function from a CoroutineScope : viewModelScope . launch { // EmptyParams is a special [InteractorParams] which you can use when the Interactor has no params. val users : List < User > = fetchUsers . execute ( EmptyParams ) } Note that the CoroutineDispatcherProvider in the constructor of the Interactor comes from the blueprint-async-coroutines artifact, which encapsulates the threading behavior with a wrapper API. Now let\u2019s implement another Interactor for updating a user profile. This interactor expects no result and we just need to know the whether it has been completed successfully. So our Interactor should again extend from SuspendingInteractor : class UpdateUserProfile ( private val userService : UserService , coroutineDispatcherProvider : CoroutineDispatcherProvider ) : SuspendingInteractor < UpdateUserProfile . Params , Unit > () { override val dispatcher : CoroutineDispatcher = coroutineDispatcherProvider . io override suspend fun doWork ( params : Params ) { userService . updateUserProfile ( params . userProfile ) } class Params ( internal val userProfile : UserProfile ) : InteractorParams } To execute this Interactor, call the execute(...) suspend function from a CoroutineScope : viewModelScope . launch { // this returns a Unit updateUserProfile . execute ( UpdateUserProfile . Params ( userProfile )) } In a reactive architecture we might want to stream any changes to the users persisted in the database to automatically re-render the UI whenever the user list has changed. In this case it makes sense to extend from the FlowInteractor : class StreamUsers ( private val userRepository : UserRepository , coroutineDispatcherProvider : CoroutineDispatcherProvider ) : FlowInteractor < EmptyParams , List < User >> () { override val dispatcher : CoroutineDispatcher = coroutineDispatcherProvider . io override fun createFlow ( params : Params ): Flow < List < User >> { return userRepository . streamUsers () // this returns a Coroutines Flow . map { users -> users . sortedBy { it . lastName } } } } On the call-side: streamUsers . buildFlow ( EmptyParams ) . onEach { users -> // propagate value of each Flow emission to LiveData<List<User>> usersLiveData . value = users } . catch { Timber . e ( it ) } // launch the collection of the Flow in the [viewModelScope] from \"androidx.lifecycle:lifecycle-viewmodel-ktx\" . launchIn ( viewModelScope ) Please check the Blueprint Coroutines Demo app for more examples of writing and testing Interactors.","title":"Usage"},{"location":"blueprint-interactor-rx2/","text":"Blueprint Interactor RxJava 2 \u00b6 This library provides building blocks for writing Interactors (use cases as defined in Clean Architecture ) based on RxJava 2 . Dependency \u00b6 implementation \"io.github.reactivecircus.blueprint:blueprint-interactor-rx2:${blueprint_version}\" Usage \u00b6 To implement an Interactor we would extend from one of the 3 classes provided: SingleInteractor for single-shot (with result) tasks CompletableInteractor for single-shot (no result) tasks ObservableInteractor for cold streams Let\u2019s say we need an Interactor for fetching a list of users from API. Since there can only be 1 response (or error), our Interactor should extend from SingleInteractor : class FetchUsers ( private val userService : UserService , schedulerProvider : SchedulerProvider ) : SingleInteractor < EmptyParams , List < User >> ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : EmptyParams ): Single < List < User >> { return userService . fetchUsers () // this returns a Single } } To execute this Interactor, build the Single and subscribe to it: disposable += fetchUsers . buildSingle ( EmptyParams ) . subscribeBy ( onSuccess = { users -> // process result }, onError = { Timber . e ( it ) } ) Note that the SchedulerProvider in the constructor of the Interactor comes from the blueprint-async-rx2 artifact, which encapsulates the threading behavior with a wrapper API. Now let\u2019s implement another Interactor for updating a user profile. This interactor expects no result and we just need to know the whether it has been completed successfully. So our Interactor should extend from CompletableInteractor : class UpdateUserProfile ( private val userService : UserService , schedulerProvider : SchedulerProvider ) : CompletableInteractor < UpdateUserProfile . Params > ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Completable { return userService . updateUserProfile ( params . userProfile ) } class Params ( internal val userProfile : UserProfile ) : InteractorParams } To execute this Interactor, build the Completable and subscribe to it: disposable += updateUserProfile . buildCompletable ( UpdateUserProfile . Params ( userProfile )). subscribeBy ( onComplete = { Timber . d ( \"Profile updated.\" ) }, onError = { Timber . e ( it ) } ) In a reactive architecture we might want to stream any changes to the users persisted in the database to automatically re-render the UI whenever the user list has changed. In this case it makes sense to extend from the ObservableInteractor : class StreamUsers ( private val userRepository : UserRepository , schedulerProvider : SchedulerProvider ) : ObservableInteractor < EmptyParams , List < User >> ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Observable < List < User >> { return userRepository . streamUsers () . map { users -> users . sortedBy { it . lastName } } } } On the call-side: disposable += streamUsers . buildObservable ( EmptyParams ) . subscribeBy ( onNext = { users -> // propagate value of each Observable emission to LiveData<List<User>> usersLiveData . value = users }, onError = { Timber . e ( it ) } ) Please check the Blueprint RxJava Demo app for more examples of writing and testing Interactors.","title":"Interactor RxJava 2"},{"location":"blueprint-interactor-rx2/#blueprint-interactor-rxjava-2","text":"This library provides building blocks for writing Interactors (use cases as defined in Clean Architecture ) based on RxJava 2 .","title":"Blueprint Interactor RxJava 2"},{"location":"blueprint-interactor-rx2/#dependency","text":"implementation \"io.github.reactivecircus.blueprint:blueprint-interactor-rx2:${blueprint_version}\"","title":"Dependency"},{"location":"blueprint-interactor-rx2/#usage","text":"To implement an Interactor we would extend from one of the 3 classes provided: SingleInteractor for single-shot (with result) tasks CompletableInteractor for single-shot (no result) tasks ObservableInteractor for cold streams Let\u2019s say we need an Interactor for fetching a list of users from API. Since there can only be 1 response (or error), our Interactor should extend from SingleInteractor : class FetchUsers ( private val userService : UserService , schedulerProvider : SchedulerProvider ) : SingleInteractor < EmptyParams , List < User >> ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : EmptyParams ): Single < List < User >> { return userService . fetchUsers () // this returns a Single } } To execute this Interactor, build the Single and subscribe to it: disposable += fetchUsers . buildSingle ( EmptyParams ) . subscribeBy ( onSuccess = { users -> // process result }, onError = { Timber . e ( it ) } ) Note that the SchedulerProvider in the constructor of the Interactor comes from the blueprint-async-rx2 artifact, which encapsulates the threading behavior with a wrapper API. Now let\u2019s implement another Interactor for updating a user profile. This interactor expects no result and we just need to know the whether it has been completed successfully. So our Interactor should extend from CompletableInteractor : class UpdateUserProfile ( private val userService : UserService , schedulerProvider : SchedulerProvider ) : CompletableInteractor < UpdateUserProfile . Params > ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Completable { return userService . updateUserProfile ( params . userProfile ) } class Params ( internal val userProfile : UserProfile ) : InteractorParams } To execute this Interactor, build the Completable and subscribe to it: disposable += updateUserProfile . buildCompletable ( UpdateUserProfile . Params ( userProfile )). subscribeBy ( onComplete = { Timber . d ( \"Profile updated.\" ) }, onError = { Timber . e ( it ) } ) In a reactive architecture we might want to stream any changes to the users persisted in the database to automatically re-render the UI whenever the user list has changed. In this case it makes sense to extend from the ObservableInteractor : class StreamUsers ( private val userRepository : UserRepository , schedulerProvider : SchedulerProvider ) : ObservableInteractor < EmptyParams , List < User >> ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Observable < List < User >> { return userRepository . streamUsers () . map { users -> users . sortedBy { it . lastName } } } } On the call-side: disposable += streamUsers . buildObservable ( EmptyParams ) . subscribeBy ( onNext = { users -> // propagate value of each Observable emission to LiveData<List<User>> usersLiveData . value = users }, onError = { Timber . e ( it ) } ) Please check the Blueprint RxJava Demo app for more examples of writing and testing Interactors.","title":"Usage"},{"location":"blueprint-interactor-rx3/","text":"Blueprint Interactor RxJava 3 \u00b6 This library provides building blocks for writing Interactors (use cases as defined in Clean Architecture ) based on RxJava 3 . Dependency \u00b6 implementation \"io.github.reactivecircus.blueprint:blueprint-interactor-rx3:${blueprint_version}\" Usage \u00b6 To implement an Interactor we would extend from one of the 3 classes provided: SingleInteractor for single-shot (with result) tasks CompletableInteractor for single-shot (no result) tasks ObservableInteractor for cold streams Let\u2019s say we need an Interactor for fetching a list of users from API. Since there can only be 1 response (or error), our Interactor should extend from SingleInteractor : class FetchUsers ( private val userService : UserService , schedulerProvider : SchedulerProvider ) : SingleInteractor < EmptyParams , List < User >> ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : EmptyParams ): Single < List < User >> { return userService . fetchUsers () // this returns a Single } } To execute this Interactor, build the Single and subscribe to it: disposable += fetchUsers . buildSingle ( EmptyParams ) . subscribeBy ( onSuccess = { users -> // process result }, onError = { Timber . e ( it ) } ) Note that the SchedulerProvider in the constructor of the Interactor comes from the blueprint-async-rx3 artifact, which encapsulates the threading behavior with a wrapper API. Now let\u2019s implement another Interactor for updating a user profile. This interactor expects no result and we just need to know the whether it has been completed successfully. So our Interactor should extend from CompletableInteractor : class UpdateUserProfile ( private val userService : UserService , schedulerProvider : SchedulerProvider ) : CompletableInteractor < UpdateUserProfile . Params > ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Completable { return userService . updateUserProfile ( params . userProfile ) } class Params ( internal val userProfile : UserProfile ) : InteractorParams } To execute this Interactor, build the Completable and subscribe to it: disposable += updateUserProfile . buildCompletable ( UpdateUserProfile . Params ( userProfile )). subscribeBy ( onComplete = { Timber . d ( \"Profile updated.\" ) }, onError = { Timber . e ( it ) } ) In a reactive architecture we might want to stream any changes to the users persisted in the database to automatically re-render the UI whenever the user list has changed. In this case it makes sense to extend from the ObservableInteractor : class StreamUsers ( private val userRepository : UserRepository , schedulerProvider : SchedulerProvider ) : ObservableInteractor < EmptyParams , List < User >> ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Observable < List < User >> { return userRepository . streamUsers () . map { users -> users . sortedBy { it . lastName } } } } On the call-side: disposable += streamUsers . buildObservable ( EmptyParams ) . subscribeBy ( onNext = { users -> // propagate value of each Observable emission to LiveData<List<User>> usersLiveData . value = users }, onError = { Timber . e ( it ) } ) Please check the Blueprint RxJava Demo app for more examples of writing and testing Interactors.","title":"Interactor RxJava 3"},{"location":"blueprint-interactor-rx3/#blueprint-interactor-rxjava-3","text":"This library provides building blocks for writing Interactors (use cases as defined in Clean Architecture ) based on RxJava 3 .","title":"Blueprint Interactor RxJava 3"},{"location":"blueprint-interactor-rx3/#dependency","text":"implementation \"io.github.reactivecircus.blueprint:blueprint-interactor-rx3:${blueprint_version}\"","title":"Dependency"},{"location":"blueprint-interactor-rx3/#usage","text":"To implement an Interactor we would extend from one of the 3 classes provided: SingleInteractor for single-shot (with result) tasks CompletableInteractor for single-shot (no result) tasks ObservableInteractor for cold streams Let\u2019s say we need an Interactor for fetching a list of users from API. Since there can only be 1 response (or error), our Interactor should extend from SingleInteractor : class FetchUsers ( private val userService : UserService , schedulerProvider : SchedulerProvider ) : SingleInteractor < EmptyParams , List < User >> ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : EmptyParams ): Single < List < User >> { return userService . fetchUsers () // this returns a Single } } To execute this Interactor, build the Single and subscribe to it: disposable += fetchUsers . buildSingle ( EmptyParams ) . subscribeBy ( onSuccess = { users -> // process result }, onError = { Timber . e ( it ) } ) Note that the SchedulerProvider in the constructor of the Interactor comes from the blueprint-async-rx3 artifact, which encapsulates the threading behavior with a wrapper API. Now let\u2019s implement another Interactor for updating a user profile. This interactor expects no result and we just need to know the whether it has been completed successfully. So our Interactor should extend from CompletableInteractor : class UpdateUserProfile ( private val userService : UserService , schedulerProvider : SchedulerProvider ) : CompletableInteractor < UpdateUserProfile . Params > ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Completable { return userService . updateUserProfile ( params . userProfile ) } class Params ( internal val userProfile : UserProfile ) : InteractorParams } To execute this Interactor, build the Completable and subscribe to it: disposable += updateUserProfile . buildCompletable ( UpdateUserProfile . Params ( userProfile )). subscribeBy ( onComplete = { Timber . d ( \"Profile updated.\" ) }, onError = { Timber . e ( it ) } ) In a reactive architecture we might want to stream any changes to the users persisted in the database to automatically re-render the UI whenever the user list has changed. In this case it makes sense to extend from the ObservableInteractor : class StreamUsers ( private val userRepository : UserRepository , schedulerProvider : SchedulerProvider ) : ObservableInteractor < EmptyParams , List < User >> ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Observable < List < User >> { return userRepository . streamUsers () . map { users -> users . sortedBy { it . lastName } } } } On the call-side: disposable += streamUsers . buildObservable ( EmptyParams ) . subscribeBy ( onNext = { users -> // propagate value of each Observable emission to LiveData<List<User>> usersLiveData . value = users }, onError = { Timber . e ( it ) } ) Please check the Blueprint RxJava Demo app for more examples of writing and testing Interactors.","title":"Usage"},{"location":"blueprint-testing-robot/","text":"Blueprint Testing Robot \u00b6 Inspired by the Robot pattern , the Blueprint Testing Robot provides a UI testing framework for authoring structured, readable, and framework-agnostic UI tests. Powered by Kotlin\u2019s higher-order functions, Blueprint Testing Robot has a comprehensive set of common view actions and assertions built-in. Dependency \u00b6 implementation \"io.github.reactivecircus.blueprint:blueprint-testing-robot:${blueprint_version}\" Usage \u00b6 Internally Blueprint Testing Robot uses Espresso to perform view actions and assertions on platform UI widgets as well as the Material components , but the consumers are not aware of the Espresso framework or the Android UI toolkit / Material Components. To write UI tests for a screen, you need: A Screen Robot responsible for driving the screen being tested, providing DSL specific to the screen. The tests themselves which use the DSL provided by the Screen Robot . A test may look like this: @Test fun clickIncrementButton_counterUpdated () { counterScreen { given { // make sure counter is reset resetCounter () } perform { // launch Activity launchActivityScenario < CounterActivity > () // increment the counter clickIncrementButton () } check { // assert that counter has been updated counterDisplayed ( expectedValue = 1 ) } } } The counterScreen block is a top-level function that you implement in your robot, which we\u2019ll look at in a minute. The given , perform , check blocks are provided by our framework to help you structure your test similar to the Given-When-Then style in BDD . The given block is used for setting up any pre-conditions required for the test. This can be omitted if your test does not depend on any data that can survive beyond the execution of a single test. When you are in the perform block, you have access to common view actions such as clickView(@IdRes viewId: Int) . Similarly when you are in the check block, you have access to common view assertions such as viewDisplayed(@IdRes vararg viewIds: Int) . However you\u2019re encouraged to write your custom actions and assertions which are specific to the screen you are testing. The clickIncrementButton() and counterDisplayed(expectedValue = 1) in the example above are custom action and assertion respectively. To implement a Robot for the test above, create a file named CounterRobot.kt : fun counterScreen ( block : CounterRobot .() -> Unit ) = CounterRobot (). apply { block () } class CounterRobot : ScreenRobot < CounterRobotActions , CounterRobotAssertions > ( CounterRobotActions (), CounterRobotAssertions () ) class CounterRobotActions : RobotActions { fun clickSaveButton () { clickView ( R . id . button_increment ) } } class CounterRobotAssertions : RobotAssertions { fun counterDisplayed ( expectedValue : Int ) { viewHasText ( R . id . text_view_counter , \" $ expectedValue \" ) } } Please check the sample apps for more examples of writing Robots and tests. Building Custom Robot Actions and Robot Assertions \u00b6 If the built-in Robot Actions and Robot Assertions are not sufficient, you can easily roll your own by implementing Kotlin extension functions on the RobotActions or RobotAssertions interface. For example to implement a double tap view action, define the following extension function in your androidTest source: import androidx.annotation.IdRes import androidx.test.espresso.Espresso import androidx.test.espresso.action.ViewActions import androidx.test.espresso.matcher.ViewMatchers import reactivecircus.blueprint.testing.RobotActions fun RobotActions . doubleClickView ( @IdRes viewId : Int ) { Espresso . onView ( ViewMatchers . withId ( viewId )). perform ( ViewActions . doubleClick ()) } Now in your robot you\u2019ll have access to this view action: class ImageGalleryRobotActions : RobotActions { fun zoomIn () { doubleClickView ( R . id . image_view_photo ) } }","title":"Testing Robot"},{"location":"blueprint-testing-robot/#blueprint-testing-robot","text":"Inspired by the Robot pattern , the Blueprint Testing Robot provides a UI testing framework for authoring structured, readable, and framework-agnostic UI tests. Powered by Kotlin\u2019s higher-order functions, Blueprint Testing Robot has a comprehensive set of common view actions and assertions built-in.","title":"Blueprint Testing Robot"},{"location":"blueprint-testing-robot/#dependency","text":"implementation \"io.github.reactivecircus.blueprint:blueprint-testing-robot:${blueprint_version}\"","title":"Dependency"},{"location":"blueprint-testing-robot/#usage","text":"Internally Blueprint Testing Robot uses Espresso to perform view actions and assertions on platform UI widgets as well as the Material components , but the consumers are not aware of the Espresso framework or the Android UI toolkit / Material Components. To write UI tests for a screen, you need: A Screen Robot responsible for driving the screen being tested, providing DSL specific to the screen. The tests themselves which use the DSL provided by the Screen Robot . A test may look like this: @Test fun clickIncrementButton_counterUpdated () { counterScreen { given { // make sure counter is reset resetCounter () } perform { // launch Activity launchActivityScenario < CounterActivity > () // increment the counter clickIncrementButton () } check { // assert that counter has been updated counterDisplayed ( expectedValue = 1 ) } } } The counterScreen block is a top-level function that you implement in your robot, which we\u2019ll look at in a minute. The given , perform , check blocks are provided by our framework to help you structure your test similar to the Given-When-Then style in BDD . The given block is used for setting up any pre-conditions required for the test. This can be omitted if your test does not depend on any data that can survive beyond the execution of a single test. When you are in the perform block, you have access to common view actions such as clickView(@IdRes viewId: Int) . Similarly when you are in the check block, you have access to common view assertions such as viewDisplayed(@IdRes vararg viewIds: Int) . However you\u2019re encouraged to write your custom actions and assertions which are specific to the screen you are testing. The clickIncrementButton() and counterDisplayed(expectedValue = 1) in the example above are custom action and assertion respectively. To implement a Robot for the test above, create a file named CounterRobot.kt : fun counterScreen ( block : CounterRobot .() -> Unit ) = CounterRobot (). apply { block () } class CounterRobot : ScreenRobot < CounterRobotActions , CounterRobotAssertions > ( CounterRobotActions (), CounterRobotAssertions () ) class CounterRobotActions : RobotActions { fun clickSaveButton () { clickView ( R . id . button_increment ) } } class CounterRobotAssertions : RobotAssertions { fun counterDisplayed ( expectedValue : Int ) { viewHasText ( R . id . text_view_counter , \" $ expectedValue \" ) } } Please check the sample apps for more examples of writing Robots and tests.","title":"Usage"},{"location":"blueprint-testing-robot/#building-custom-robot-actions-and-robot-assertions","text":"If the built-in Robot Actions and Robot Assertions are not sufficient, you can easily roll your own by implementing Kotlin extension functions on the RobotActions or RobotAssertions interface. For example to implement a double tap view action, define the following extension function in your androidTest source: import androidx.annotation.IdRes import androidx.test.espresso.Espresso import androidx.test.espresso.action.ViewActions import androidx.test.espresso.matcher.ViewMatchers import reactivecircus.blueprint.testing.RobotActions fun RobotActions . doubleClickView ( @IdRes viewId : Int ) { Espresso . onView ( ViewMatchers . withId ( viewId )). perform ( ViewActions . doubleClick ()) } Now in your robot you\u2019ll have access to this view action: class ImageGalleryRobotActions : RobotActions { fun zoomIn () { doubleClickView ( R . id . image_view_photo ) } }","title":"Building Custom Robot Actions and Robot Assertions"},{"location":"blueprint-ui/","text":"Blueprint UI \u00b6 The Blueprint UI provides a number of convenient Kotlin extensions and widgets for working with the Android UI toolkit. Dependency \u00b6 implementation \"io.github.reactivecircus.blueprint:blueprint-ui:${blueprint_version}\" Note that the library uses androidx.appcompat:appcompat transitively. Extensions \u00b6 Kotlin extensions on Activity : /** * Shows status bar on the activity. */ fun Activity . showStatusBar () /** * Hides status bar from the activity. */ fun Activity . hideStatusBar () /** * Sets status bar color on the activity and optionally draws the status bar system ui in light or dark mode. */ fun Activity . setStatusBarColor ( @ColorRes colorRes : Int , lightBackground : Boolean = false ) /** * Returns screen size of the activity. */ val Activity . screenSize : DisplayMetrics Kotlin extensions on Context : /** * Apply tinting to a vector drawable. */ fun Context . tintVectorDrawable ( theme : Resources . Theme , @DrawableRes resId : Int , @ColorInt tint : Int ): Drawable /** * Whether animation is turned on on the device. */ val Context . isAnimationOn : Boolean Kotlin extensions on AppCompat : /** * Sets the precomputed text future on the [AppCompatTextView]. * * @param charSequence the text to be displayed * @param executor the executor to be used for processing the text layout. * Default single threaded pool will be used if null is passed in. */ fun AppCompatTextView . setPrecomputedTextFuture ( charSequence : CharSequence , executor : Executor? = null ) Kotlin extensions on Window : /** * Programmatically shows the soft keyboard. */ fun Window . showSoftKeyboard () /** * Programmatically hides the soft keyboard. */ fun Window . hideSoftKeyboard () Intent.kt has extensions on Activity and Context for launching new activity. For example to launch a new Activity from an Activity: launchActivity < NoteActivity > { putExtra ( EXTRA_ENTER_NOTE_ID , 1 ) } To launch a new Activity, passing in a request code : launchActivity < ScanQrCodeActivity > ( requestCode = SCAN_QR_CODE_REQUEST ) This internally launches the activity with Activity.startActivityForResult(...) .","title":"UI"},{"location":"blueprint-ui/#blueprint-ui","text":"The Blueprint UI provides a number of convenient Kotlin extensions and widgets for working with the Android UI toolkit.","title":"Blueprint UI"},{"location":"blueprint-ui/#dependency","text":"implementation \"io.github.reactivecircus.blueprint:blueprint-ui:${blueprint_version}\" Note that the library uses androidx.appcompat:appcompat transitively.","title":"Dependency"},{"location":"blueprint-ui/#extensions","text":"Kotlin extensions on Activity : /** * Shows status bar on the activity. */ fun Activity . showStatusBar () /** * Hides status bar from the activity. */ fun Activity . hideStatusBar () /** * Sets status bar color on the activity and optionally draws the status bar system ui in light or dark mode. */ fun Activity . setStatusBarColor ( @ColorRes colorRes : Int , lightBackground : Boolean = false ) /** * Returns screen size of the activity. */ val Activity . screenSize : DisplayMetrics Kotlin extensions on Context : /** * Apply tinting to a vector drawable. */ fun Context . tintVectorDrawable ( theme : Resources . Theme , @DrawableRes resId : Int , @ColorInt tint : Int ): Drawable /** * Whether animation is turned on on the device. */ val Context . isAnimationOn : Boolean Kotlin extensions on AppCompat : /** * Sets the precomputed text future on the [AppCompatTextView]. * * @param charSequence the text to be displayed * @param executor the executor to be used for processing the text layout. * Default single threaded pool will be used if null is passed in. */ fun AppCompatTextView . setPrecomputedTextFuture ( charSequence : CharSequence , executor : Executor? = null ) Kotlin extensions on Window : /** * Programmatically shows the soft keyboard. */ fun Window . showSoftKeyboard () /** * Programmatically hides the soft keyboard. */ fun Window . hideSoftKeyboard () Intent.kt has extensions on Activity and Context for launching new activity. For example to launch a new Activity from an Activity: launchActivity < NoteActivity > { putExtra ( EXTRA_ENTER_NOTE_ID , 1 ) } To launch a new Activity, passing in a request code : launchActivity < ScanQrCodeActivity > ( requestCode = SCAN_QR_CODE_REQUEST ) This internally launches the activity with Activity.startActivityForResult(...) .","title":"Extensions"},{"location":"samples/","text":"Blueprint Samples \u00b6 These samples showcase how you may integrate Blueprint in your project by implementing a simple note taking app. There are 2 flavors of the demo app: demo-coroutines - powered by Kotlin Coroutines and Flow and various Blueprint libraries. demo-rx - powered by RxJava 3 and various Blueprint libraries. Dependencies \u00b6 Since the 2 demo apps have identical functionality, we are able to share a lot of common code between the apps by having a couple of common library modules. demo-coroutines \u00b6 This app module uses the following Blueprint libraries: blueprint-interactor-coroutines blueprint-async-coroutines blueprint-ui blueprint-testing-robot It also depends on the demo-common and demo-testing-common modules. demo-rx \u00b6 This app module uses the following Blueprint libraries: blueprint-interactor-rx3 blueprint-async-rx3 blueprint-ui blueprint-testing-robot It also depends on the demo-common and demo-testing-common modules. demo-common \u00b6 This library module includes common code shared between the 2 apps such as resources, layouts, and in-memory cache. demo-testing-common \u00b6 This library module includes common UI testing infra code shared between the 2 apps such as instrumentation robots and test data. Comparison \u00b6 The demo apps follow Clean Architecture , but the only part relevant to Blueprint is the domain layer which contains Use Cases (also known as Interactors) . One of the key differences between the Coroutines-based and RxJava-based implementations is how Interactors are implemented: The Coroutines-based implementation uses SuspendingInteractor for single-shot tasks and FlowInteractor for cold streams. The RxJava-based implementation uses SingleInteractor and CompletableInteractor for single-shot tasks and ObservableInteractor for cold streams. Single-shot Task Cold Stream blueprint-interactor-coroutines SuspendingInteractor FlowInteractor blueprint-interactor-rx3 SingleInteractor , CompletableInteractor ObservableInteractor Consequently the 2 different Interactor implementations expose different async primitives to downstream: Coroutines-based Interactors - expose suspend function and Kotlin Flow to consumers. RxJava-based Interactors - expose RxJava Single , Completable and Observable to consumers. Another difference is the wrapper APIs for encapsulated threading behavior : The Coroutines-based implementation uses CoroutineDispatcherProvider from the blueprint-async-coroutines library. The RxJava-based implementation uses SchedulerProvider from the blueprint-async-rx3 library. They offer the same abstraction to help with DI and testing, but one interacts with Kotlin\u2019s CoroutineDispatcher API and the other one interacts with RxJava\u2019s Scheduler API. Notes \u00b6 While these samples implement layered-architecture and have comprehensive unit tests and UI tests, they most definitely do not represent how one should approach building a production quality app. A number of important things are left out as our focus here is how the Blueprint libraries can be integrated in your codebase: We implemented a very simple Dependency Injection (Service Locator to be precise) framework. Consider using Dagger or Koin in a real project. Different layers (e.g. domain , data , presentation ) should probably live in their own modules in a real project. Both samples use AndroidX ViewModel in the presentation layer. For better managing complex states you might want to consider using a redux-based architecture that employs Uni-directional Data Flow . I personally recommend RxRedux and its Coroutines-based equivalent. In a real project you will want to set up product flavors for different environments (e.g. mock, staging, production). Obviously the apps don\u2019t talk to any backend APIs and lack persistent storage. For a better representation of a highly-modularized, production-quality app that uses Blueprint , you may want to take a look at ReleaseProbe .","title":"Demos Overview"},{"location":"samples/#blueprint-samples","text":"These samples showcase how you may integrate Blueprint in your project by implementing a simple note taking app. There are 2 flavors of the demo app: demo-coroutines - powered by Kotlin Coroutines and Flow and various Blueprint libraries. demo-rx - powered by RxJava 3 and various Blueprint libraries.","title":"Blueprint Samples"},{"location":"samples/#dependencies","text":"Since the 2 demo apps have identical functionality, we are able to share a lot of common code between the apps by having a couple of common library modules.","title":"Dependencies"},{"location":"samples/#demo-coroutines","text":"This app module uses the following Blueprint libraries: blueprint-interactor-coroutines blueprint-async-coroutines blueprint-ui blueprint-testing-robot It also depends on the demo-common and demo-testing-common modules.","title":"demo-coroutines"},{"location":"samples/#demo-rx","text":"This app module uses the following Blueprint libraries: blueprint-interactor-rx3 blueprint-async-rx3 blueprint-ui blueprint-testing-robot It also depends on the demo-common and demo-testing-common modules.","title":"demo-rx"},{"location":"samples/#demo-common","text":"This library module includes common code shared between the 2 apps such as resources, layouts, and in-memory cache.","title":"demo-common"},{"location":"samples/#demo-testing-common","text":"This library module includes common UI testing infra code shared between the 2 apps such as instrumentation robots and test data.","title":"demo-testing-common"},{"location":"samples/#comparison","text":"The demo apps follow Clean Architecture , but the only part relevant to Blueprint is the domain layer which contains Use Cases (also known as Interactors) . One of the key differences between the Coroutines-based and RxJava-based implementations is how Interactors are implemented: The Coroutines-based implementation uses SuspendingInteractor for single-shot tasks and FlowInteractor for cold streams. The RxJava-based implementation uses SingleInteractor and CompletableInteractor for single-shot tasks and ObservableInteractor for cold streams. Single-shot Task Cold Stream blueprint-interactor-coroutines SuspendingInteractor FlowInteractor blueprint-interactor-rx3 SingleInteractor , CompletableInteractor ObservableInteractor Consequently the 2 different Interactor implementations expose different async primitives to downstream: Coroutines-based Interactors - expose suspend function and Kotlin Flow to consumers. RxJava-based Interactors - expose RxJava Single , Completable and Observable to consumers. Another difference is the wrapper APIs for encapsulated threading behavior : The Coroutines-based implementation uses CoroutineDispatcherProvider from the blueprint-async-coroutines library. The RxJava-based implementation uses SchedulerProvider from the blueprint-async-rx3 library. They offer the same abstraction to help with DI and testing, but one interacts with Kotlin\u2019s CoroutineDispatcher API and the other one interacts with RxJava\u2019s Scheduler API.","title":"Comparison"},{"location":"samples/#notes","text":"While these samples implement layered-architecture and have comprehensive unit tests and UI tests, they most definitely do not represent how one should approach building a production quality app. A number of important things are left out as our focus here is how the Blueprint libraries can be integrated in your codebase: We implemented a very simple Dependency Injection (Service Locator to be precise) framework. Consider using Dagger or Koin in a real project. Different layers (e.g. domain , data , presentation ) should probably live in their own modules in a real project. Both samples use AndroidX ViewModel in the presentation layer. For better managing complex states you might want to consider using a redux-based architecture that employs Uni-directional Data Flow . I personally recommend RxRedux and its Coroutines-based equivalent. In a real project you will want to set up product flavors for different environments (e.g. mock, staging, production). Obviously the apps don\u2019t talk to any backend APIs and lack persistent storage. For a better representation of a highly-modularized, production-quality app that uses Blueprint , you may want to take a look at ReleaseProbe .","title":"Notes"},{"location":"samples/demo-common/","text":"Blueprint Demo Common \u00b6 This is a library module shared by both demo-coroutines and demo-rx . This has nothing to do with Blueprint and just provides common code used by both apps: Resources An in-memory cache Domain model A couple of utils and extensions","title":"Demo Shared Library"},{"location":"samples/demo-common/#blueprint-demo-common","text":"This is a library module shared by both demo-coroutines and demo-rx . This has nothing to do with Blueprint and just provides common code used by both apps: Resources An in-memory cache Domain model A couple of utils and extensions","title":"Blueprint Demo Common"},{"location":"samples/demo-coroutines/","text":"Blueprint Coroutines Demo \u00b6 This is simple note taking app for demonstrating how to use Blueprint in a codebase that uses Kotlin Coroutines and Flow . Interactors \u00b6 The demo app follows Clean Architecture . The Use Cases (also known as Interactors) define and encapsulate business rules specific to the application. The blueprint-interactor-coroutines artifact provides 2 base classes for building Interactors: SuspendingInteractor for single-shot tasks FlowInteractor for cold streams An example implementation of SuspendingInteractor in the app: class CoroutinesCreateNote ( private val noteRepository : CoroutinesNoteRepository , coroutineDispatcherProvider : CoroutineDispatcherProvider ) : SuspendingInteractor < CoroutinesCreateNote . Params , Unit > () { override val dispatcher : CoroutineDispatcher = coroutineDispatcherProvider . io override suspend fun doWork ( params : Params ) { noteRepository . addNote ( params . note ) } class Params ( internal val note : Note ) : InteractorParams } Call-side: viewModelScope . launch { val time = System . currentTimeMillis () val newNote = Note ( content = content , timeCreated = time , timeLastUpdated = time ) createNote . execute ( CoroutinesCreateNote . Params ( newNote )) } An example implementation of FlowInteractor in the app: class CoroutinesStreamAllNotes ( private val noteRepository : CoroutinesNoteRepository , coroutineDispatcherProvider : CoroutineDispatcherProvider ) : FlowInteractor < CoroutinesStreamAllNotes . Params , List < Note >> () { override val dispatcher : CoroutineDispatcher = coroutineDispatcherProvider . io override fun createFlow ( params : Params ): Flow < List < Note >> { return noteRepository . streamAllNotes () . map { notes -> if ( params . sortedBy === SortedBy . TIME_CREATED ) { notes . sortedByDescending { it . timeCreated } } else { notes . sortedByDescending { it . timeLastUpdated } } } } class Params ( internal val sortedBy : SortedBy ) : InteractorParams enum class SortedBy { TIME_CREATED , TIME_LAST_UPDATED } } Call-side: streamAllNotes . buildFlow ( CoroutinesStreamAllNotes . Params ( CoroutinesStreamAllNotes . SortedBy . TIME_LAST_UPDATED )) . map { State . Idle ( it ) } . onStart < State > { emit ( State . LoadingNotes ) } . onEach { // propagate value of each Flow emission to LiveData<State> notesLiveData . value = it } . catch { Timber . e ( it ) } // launch the collection of the Flow in the [viewModelScope] from \"androidx.lifecycle:lifecycle-viewmodel-ktx\" . launchIn ( viewModelScope ) Threading \u00b6 The CoroutineDispatcherProvider from the examples above is responsible encapsulating the threading behavior with a wrapper API. This class from the blueprint-async-coroutines artifact has 3 properties, representing the common groups of threading use cases in an app: io: CoroutineDispatcher - Dispatcher for IO-bound work computation: CoroutineDispatcher - Dispatcher for computational work ui: CoroutineDispatcher - Dispatcher for UI work An instance of this can be injected to classes which are concerned about executing code on different threads, but they don\u2019t and shouldn\u2019t need to know about the underlying implementation. A single-threaded version for example can be injected for testing. Practically you\u2019ll likely only have 1 instance of CoroutineDispatcherProvider in the production environment and use DI to inject it into anywhere in the codebase where certain threading behavior is required: CoroutineDispatcherProvider ( io = Dispatchers . IO , computation = Dispatchers . Default , ui = Dispatchers . Main . immediate ) In unit tests you can easily swap out the implementation to make sure code is executed in a single thread: CoroutineDispatcherProvider ( io = testCoroutineDispatcher , computation = testCoroutineDispatcher , ui = testCoroutineDispatcher ) where testCoroutineDispatcher is an instance of TestCoroutineDispatcher from the org.jetbrains.kotlinx:kotlinx-coroutines-test library. For a full example please look at the unit tests for Interactors e.g. CoroutinesStreamAllNotesTest.kt . UI Widget and Extensions \u00b6 The demo app uses various Kotlin extensions and widget from the blueprint-ui artifact: For launching a new Activity from an Activity: launchActivity < CoroutinesEnterNoteActivity > { putExtra ( EXTRA_ENTER_NOTE_PARAMS , EnterNoteParams . CreateNew ) } UI Testing \u00b6 The UI testing framework and Testing Robot DSL from the blueprint-testing-robot provide the building blocks for authoring structured, readable, and framework-agnostic UI tests. An example of a test case: @Test fun openNotesListScreenWithExistingNotes_notesDisplayed () { notesListScreen { given { noteCache . addNotes ( testNotes ) } perform { launchActivityScenario < CoroutinesNotesListActivity > () } check { createNoteButtonDisplayed () notesDisplayed ( testNotes ) } } } This DSL is powered by a custom Screen Robot implementation. Examples can be found in demo-testing-common . Building \u00b6 To compile the app: ./gradlew demo-coroutines:assemble To run unit tests, lint and detekt: ./gradlew demo-coroutines:check To run UI (on-device) tests: ./gradlew demo-coroutines:connectedCheck","title":"Coroutines Demo"},{"location":"samples/demo-coroutines/#blueprint-coroutines-demo","text":"This is simple note taking app for demonstrating how to use Blueprint in a codebase that uses Kotlin Coroutines and Flow .","title":"Blueprint Coroutines Demo"},{"location":"samples/demo-coroutines/#interactors","text":"The demo app follows Clean Architecture . The Use Cases (also known as Interactors) define and encapsulate business rules specific to the application. The blueprint-interactor-coroutines artifact provides 2 base classes for building Interactors: SuspendingInteractor for single-shot tasks FlowInteractor for cold streams An example implementation of SuspendingInteractor in the app: class CoroutinesCreateNote ( private val noteRepository : CoroutinesNoteRepository , coroutineDispatcherProvider : CoroutineDispatcherProvider ) : SuspendingInteractor < CoroutinesCreateNote . Params , Unit > () { override val dispatcher : CoroutineDispatcher = coroutineDispatcherProvider . io override suspend fun doWork ( params : Params ) { noteRepository . addNote ( params . note ) } class Params ( internal val note : Note ) : InteractorParams } Call-side: viewModelScope . launch { val time = System . currentTimeMillis () val newNote = Note ( content = content , timeCreated = time , timeLastUpdated = time ) createNote . execute ( CoroutinesCreateNote . Params ( newNote )) } An example implementation of FlowInteractor in the app: class CoroutinesStreamAllNotes ( private val noteRepository : CoroutinesNoteRepository , coroutineDispatcherProvider : CoroutineDispatcherProvider ) : FlowInteractor < CoroutinesStreamAllNotes . Params , List < Note >> () { override val dispatcher : CoroutineDispatcher = coroutineDispatcherProvider . io override fun createFlow ( params : Params ): Flow < List < Note >> { return noteRepository . streamAllNotes () . map { notes -> if ( params . sortedBy === SortedBy . TIME_CREATED ) { notes . sortedByDescending { it . timeCreated } } else { notes . sortedByDescending { it . timeLastUpdated } } } } class Params ( internal val sortedBy : SortedBy ) : InteractorParams enum class SortedBy { TIME_CREATED , TIME_LAST_UPDATED } } Call-side: streamAllNotes . buildFlow ( CoroutinesStreamAllNotes . Params ( CoroutinesStreamAllNotes . SortedBy . TIME_LAST_UPDATED )) . map { State . Idle ( it ) } . onStart < State > { emit ( State . LoadingNotes ) } . onEach { // propagate value of each Flow emission to LiveData<State> notesLiveData . value = it } . catch { Timber . e ( it ) } // launch the collection of the Flow in the [viewModelScope] from \"androidx.lifecycle:lifecycle-viewmodel-ktx\" . launchIn ( viewModelScope )","title":"Interactors"},{"location":"samples/demo-coroutines/#threading","text":"The CoroutineDispatcherProvider from the examples above is responsible encapsulating the threading behavior with a wrapper API. This class from the blueprint-async-coroutines artifact has 3 properties, representing the common groups of threading use cases in an app: io: CoroutineDispatcher - Dispatcher for IO-bound work computation: CoroutineDispatcher - Dispatcher for computational work ui: CoroutineDispatcher - Dispatcher for UI work An instance of this can be injected to classes which are concerned about executing code on different threads, but they don\u2019t and shouldn\u2019t need to know about the underlying implementation. A single-threaded version for example can be injected for testing. Practically you\u2019ll likely only have 1 instance of CoroutineDispatcherProvider in the production environment and use DI to inject it into anywhere in the codebase where certain threading behavior is required: CoroutineDispatcherProvider ( io = Dispatchers . IO , computation = Dispatchers . Default , ui = Dispatchers . Main . immediate ) In unit tests you can easily swap out the implementation to make sure code is executed in a single thread: CoroutineDispatcherProvider ( io = testCoroutineDispatcher , computation = testCoroutineDispatcher , ui = testCoroutineDispatcher ) where testCoroutineDispatcher is an instance of TestCoroutineDispatcher from the org.jetbrains.kotlinx:kotlinx-coroutines-test library. For a full example please look at the unit tests for Interactors e.g. CoroutinesStreamAllNotesTest.kt .","title":"Threading"},{"location":"samples/demo-coroutines/#ui-widget-and-extensions","text":"The demo app uses various Kotlin extensions and widget from the blueprint-ui artifact: For launching a new Activity from an Activity: launchActivity < CoroutinesEnterNoteActivity > { putExtra ( EXTRA_ENTER_NOTE_PARAMS , EnterNoteParams . CreateNew ) }","title":"UI Widget and Extensions"},{"location":"samples/demo-coroutines/#ui-testing","text":"The UI testing framework and Testing Robot DSL from the blueprint-testing-robot provide the building blocks for authoring structured, readable, and framework-agnostic UI tests. An example of a test case: @Test fun openNotesListScreenWithExistingNotes_notesDisplayed () { notesListScreen { given { noteCache . addNotes ( testNotes ) } perform { launchActivityScenario < CoroutinesNotesListActivity > () } check { createNoteButtonDisplayed () notesDisplayed ( testNotes ) } } } This DSL is powered by a custom Screen Robot implementation. Examples can be found in demo-testing-common .","title":"UI Testing"},{"location":"samples/demo-coroutines/#building","text":"To compile the app: ./gradlew demo-coroutines:assemble To run unit tests, lint and detekt: ./gradlew demo-coroutines:check To run UI (on-device) tests: ./gradlew demo-coroutines:connectedCheck","title":"Building"},{"location":"samples/demo-rx/","text":"Blueprint RxJava Demo \u00b6 This is simple note taking app for demonstrating how to use Blueprint in a codebase that uses RxJava . Interactors \u00b6 The demo app follows Clean Architecture . The Use Cases (also known as Interactors) define and encapsulate business rules specific to the application. The blueprint-interactor-rx3 artifact provides 3 base classes for building Interactors: SingleInteractor for single-shot (with result) tasks CompletableInteractor for single-shot (no result) tasks ObservableInteractor for cold streams An example implementation of SingleInteractor in the app: class RxGetNoteByUuid ( private val noteRepository : RxNoteRepository , schedulerProvider : SchedulerProvider ) : SingleInteractor < RxGetNoteByUuid . Params , Note > ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Single < Note > { return noteRepository . getNoteByUuid ( params . uuid ) . switchIfEmpty ( Maybe . error ( IllegalStateException ( \"Could not find note by uuid.\" )) ) . toSingle () } class Params ( internal val uuid : String ) : InteractorParams } Call-side: disposable += getNoteByUuid . buildSingle ( RxGetNoteByUuid . Params ( noteUuid )) . subscribeBy ( onSuccess = { note -> noteLiveData . value = State ( note ) }, onError = { Timber . e ( it ) } ) An example implementation of CompletableInteractor in the app: class RxUpdateNote ( private val noteRepository : RxNoteRepository , schedulerProvider : SchedulerProvider ) : CompletableInteractor < RxUpdateNote . Params > ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Completable { return noteRepository . updateNote ( params . note ) } class Params ( internal val note : Note ) : InteractorParams } Call-side: disposable += updateNote . buildCompletable ( RxUpdateNote . Params ( updatedNote )). subscribeBy ( onComplete = { Timber . d ( \"Note updated.\" ) }, onError = { Timber . e ( it ) } ) An example implementation of ObservableInteractor in the app: class RxStreamAllNotes ( private val noteRepository : RxNoteRepository , schedulerProvider : SchedulerProvider ) : ObservableInteractor < RxStreamAllNotes . Params , List < Note >> ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Observable < List < Note >> { return noteRepository . streamAllNotes () . map { notes -> if ( params . sortedBy === SortedBy . TIME_CREATED ) { notes . sortedByDescending { it . timeCreated } } else { notes . sortedByDescending { it . timeLastUpdated } } } } class Params ( internal val sortedBy : SortedBy ) : InteractorParams enum class SortedBy { TIME_CREATED , TIME_LAST_UPDATED } } Call-side: disposable += streamAllNotes . buildObservable ( RxStreamAllNotes . Params ( RxStreamAllNotes . SortedBy . TIME_LAST_UPDATED ) ) . map < State > { State . Idle ( it ) } . startWith ( State . LoadingNotes ) . subscribeBy ( onNext = { notesLiveData . value = it }, onError = { Timber . e ( it ) } ) Threading \u00b6 The SchedulerProvider from the examples above is responsible encapsulating the threading behavior with a wrapper API. This class from the blueprint-async-rx3 artifact has 3 properties, representing the common groups of threading use cases in an app: io: Scheduler - Scheduler for IO-bound work computation: Scheduler - Scheduler for computational work ui: Scheduler - Scheduler for UI work An instance of this can be injected to classes which are concerned about executing code on different threads, but they don\u2019t and shouldn\u2019t need to know about the underlying implementation. A single-threaded version for example can be injected for testing. Practically you\u2019ll likely only have 1 instance of SchedulerProvider in the production environment and use DI to inject it into anywhere in the codebase where certain threading behavior is required: SchedulerProvider ( io = Schedulers . io (), computation = Schedulers . computation (), ui = AndroidSchedulers . mainThread () ) In unit tests you can easily swap out the implementation to make sure code is executed in a single thread: SchedulerProvider ( io = Schedulers . trampoline (), computation = Schedulers . trampoline (), ui = Schedulers . trampoline () ) For a full example please look at the unit tests for Interactors e.g. RxStreamAllNotesTest.kt . UI Widget and Extensions \u00b6 The demo app uses various Kotlin extensions and widget from the blueprint-ui artifact: For launching a new Activity from an Activity: launchActivity < RxEnterNoteActivity > { putExtra ( EXTRA_ENTER_NOTE_PARAMS , EnterNoteParams . CreateNew ) } UI Testing \u00b6 The UI testing framework and Testing Robot DSL from the blueprint-testing-robot provide the building blocks for authoring structured, readable, and framework-agnostic UI tests. An example of a test case: @Test fun openNotesListScreenWithExistingNotes_notesDisplayed () { notesListScreen { given { noteCache . addNotes ( testNotes ) } perform { launchActivityScenario < RxNotesListActivity > () } check { createNoteButtonDisplayed () notesDisplayed ( testNotes ) } } } This DSL is powered by a custom Screen Robot implementation. Examples can be found in demo-testing-common . Building \u00b6 To compile the app: ./gradlew demo-rx:assemble To run unit tests, lint and detekt: ./gradlew demo-rx:check To run UI (on-device) tests: ./gradlew demo-rx:connectedCheck","title":"RxJava Demo"},{"location":"samples/demo-rx/#blueprint-rxjava-demo","text":"This is simple note taking app for demonstrating how to use Blueprint in a codebase that uses RxJava .","title":"Blueprint RxJava Demo"},{"location":"samples/demo-rx/#interactors","text":"The demo app follows Clean Architecture . The Use Cases (also known as Interactors) define and encapsulate business rules specific to the application. The blueprint-interactor-rx3 artifact provides 3 base classes for building Interactors: SingleInteractor for single-shot (with result) tasks CompletableInteractor for single-shot (no result) tasks ObservableInteractor for cold streams An example implementation of SingleInteractor in the app: class RxGetNoteByUuid ( private val noteRepository : RxNoteRepository , schedulerProvider : SchedulerProvider ) : SingleInteractor < RxGetNoteByUuid . Params , Note > ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Single < Note > { return noteRepository . getNoteByUuid ( params . uuid ) . switchIfEmpty ( Maybe . error ( IllegalStateException ( \"Could not find note by uuid.\" )) ) . toSingle () } class Params ( internal val uuid : String ) : InteractorParams } Call-side: disposable += getNoteByUuid . buildSingle ( RxGetNoteByUuid . Params ( noteUuid )) . subscribeBy ( onSuccess = { note -> noteLiveData . value = State ( note ) }, onError = { Timber . e ( it ) } ) An example implementation of CompletableInteractor in the app: class RxUpdateNote ( private val noteRepository : RxNoteRepository , schedulerProvider : SchedulerProvider ) : CompletableInteractor < RxUpdateNote . Params > ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Completable { return noteRepository . updateNote ( params . note ) } class Params ( internal val note : Note ) : InteractorParams } Call-side: disposable += updateNote . buildCompletable ( RxUpdateNote . Params ( updatedNote )). subscribeBy ( onComplete = { Timber . d ( \"Note updated.\" ) }, onError = { Timber . e ( it ) } ) An example implementation of ObservableInteractor in the app: class RxStreamAllNotes ( private val noteRepository : RxNoteRepository , schedulerProvider : SchedulerProvider ) : ObservableInteractor < RxStreamAllNotes . Params , List < Note >> ( ioScheduler = schedulerProvider . io , uiScheduler = schedulerProvider . ui ) { override fun createInteractor ( params : Params ): Observable < List < Note >> { return noteRepository . streamAllNotes () . map { notes -> if ( params . sortedBy === SortedBy . TIME_CREATED ) { notes . sortedByDescending { it . timeCreated } } else { notes . sortedByDescending { it . timeLastUpdated } } } } class Params ( internal val sortedBy : SortedBy ) : InteractorParams enum class SortedBy { TIME_CREATED , TIME_LAST_UPDATED } } Call-side: disposable += streamAllNotes . buildObservable ( RxStreamAllNotes . Params ( RxStreamAllNotes . SortedBy . TIME_LAST_UPDATED ) ) . map < State > { State . Idle ( it ) } . startWith ( State . LoadingNotes ) . subscribeBy ( onNext = { notesLiveData . value = it }, onError = { Timber . e ( it ) } )","title":"Interactors"},{"location":"samples/demo-rx/#threading","text":"The SchedulerProvider from the examples above is responsible encapsulating the threading behavior with a wrapper API. This class from the blueprint-async-rx3 artifact has 3 properties, representing the common groups of threading use cases in an app: io: Scheduler - Scheduler for IO-bound work computation: Scheduler - Scheduler for computational work ui: Scheduler - Scheduler for UI work An instance of this can be injected to classes which are concerned about executing code on different threads, but they don\u2019t and shouldn\u2019t need to know about the underlying implementation. A single-threaded version for example can be injected for testing. Practically you\u2019ll likely only have 1 instance of SchedulerProvider in the production environment and use DI to inject it into anywhere in the codebase where certain threading behavior is required: SchedulerProvider ( io = Schedulers . io (), computation = Schedulers . computation (), ui = AndroidSchedulers . mainThread () ) In unit tests you can easily swap out the implementation to make sure code is executed in a single thread: SchedulerProvider ( io = Schedulers . trampoline (), computation = Schedulers . trampoline (), ui = Schedulers . trampoline () ) For a full example please look at the unit tests for Interactors e.g. RxStreamAllNotesTest.kt .","title":"Threading"},{"location":"samples/demo-rx/#ui-widget-and-extensions","text":"The demo app uses various Kotlin extensions and widget from the blueprint-ui artifact: For launching a new Activity from an Activity: launchActivity < RxEnterNoteActivity > { putExtra ( EXTRA_ENTER_NOTE_PARAMS , EnterNoteParams . CreateNew ) }","title":"UI Widget and Extensions"},{"location":"samples/demo-rx/#ui-testing","text":"The UI testing framework and Testing Robot DSL from the blueprint-testing-robot provide the building blocks for authoring structured, readable, and framework-agnostic UI tests. An example of a test case: @Test fun openNotesListScreenWithExistingNotes_notesDisplayed () { notesListScreen { given { noteCache . addNotes ( testNotes ) } perform { launchActivityScenario < RxNotesListActivity > () } check { createNoteButtonDisplayed () notesDisplayed ( testNotes ) } } } This DSL is powered by a custom Screen Robot implementation. Examples can be found in demo-testing-common .","title":"UI Testing"},{"location":"samples/demo-rx/#building","text":"To compile the app: ./gradlew demo-rx:assemble To run unit tests, lint and detekt: ./gradlew demo-rx:check To run UI (on-device) tests: ./gradlew demo-rx:connectedCheck","title":"Building"},{"location":"samples/demo-testing-common/","text":"Blueprint Demo Testing Infrastructure \u00b6 This library module has common UI testing infra code shared by the 2 apps, including the screen robots and test data . A Screen Robot implementation uses the predefined view actions, view assertions and Robot DSL from the blueprint-testing-robot artifact to provide a layer of abstraction on top of the more general and primitive instrumentation commands. An example of a Robot implementation: fun enterNoteScreen ( block : EnterNoteRobot .() -> Unit ) = EnterNoteRobot (). apply { block () } class EnterNoteRobot : ScreenRobot < EnterNoteRobotActions , EnterNoteRobotAssertions > ( EnterNoteRobotActions (), EnterNoteRobotAssertions () ) class EnterNoteRobotActions : RobotActions { fun enterNote ( note : String ) { replaceTextInView ( R . id . edit_text_note , note ) } fun clickSaveButton () { clickView ( R . id . action_save ) } } class EnterNoteRobotAssertions : RobotAssertions { fun createNoteScreenTitleDisplayed () { toolbarHasTitle ( R . string . title_create_note ) } fun updateNoteScreenTitleDisplayed () { toolbarHasTitle ( R . string . title_update_note ) } fun noteDisplayed ( note : String ) { viewHasText ( R . id . edit_text_note , note ) } } If the built-in robot actions and robot assertions are not sufficient, you can roll your custom actions or assertions directly using Espresso . Have a look at the custom Robot Action example in blueprint-testing-robot .","title":"Demo Testing Infrastructure"},{"location":"samples/demo-testing-common/#blueprint-demo-testing-infrastructure","text":"This library module has common UI testing infra code shared by the 2 apps, including the screen robots and test data . A Screen Robot implementation uses the predefined view actions, view assertions and Robot DSL from the blueprint-testing-robot artifact to provide a layer of abstraction on top of the more general and primitive instrumentation commands. An example of a Robot implementation: fun enterNoteScreen ( block : EnterNoteRobot .() -> Unit ) = EnterNoteRobot (). apply { block () } class EnterNoteRobot : ScreenRobot < EnterNoteRobotActions , EnterNoteRobotAssertions > ( EnterNoteRobotActions (), EnterNoteRobotAssertions () ) class EnterNoteRobotActions : RobotActions { fun enterNote ( note : String ) { replaceTextInView ( R . id . edit_text_note , note ) } fun clickSaveButton () { clickView ( R . id . action_save ) } } class EnterNoteRobotAssertions : RobotAssertions { fun createNoteScreenTitleDisplayed () { toolbarHasTitle ( R . string . title_create_note ) } fun updateNoteScreenTitleDisplayed () { toolbarHasTitle ( R . string . title_update_note ) } fun noteDisplayed ( note : String ) { viewHasText ( R . id . edit_text_note , note ) } } If the built-in robot actions and robot assertions are not sufficient, you can roll your custom actions or assertions directly using Espresso . Have a look at the custom Robot Action example in blueprint-testing-robot .","title":"Blueprint Demo Testing Infrastructure"}]}